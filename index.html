<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-dark.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Sbt-interactive-tutorial by imarios</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Sbt-interactive-tutorial</h1>
          <h2>A tutorial that emphasizes how to use sbt as an interactive build tool. </h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/imarios/sbt-interactive-tutorial/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/imarios/sbt-interactive-tutorial/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/imarios/sbt-interactive-tutorial" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h2>
<a id="sbt-the-interactive-tutorial" class="anchor" href="#sbt-the-interactive-tutorial" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>sbt: The interactive tutorial</h2>

<p><em>(Covers Scala 2.11.8 and sbt 0.13.11)</em></p>

<p><strong>Goal:</strong> The goal of this tutorial is to emphasize on how to use sbt as an interactive build tool. 
It targets audience that is new to sbt or has been using sbt for few months.</p>

<p><strong>Q:</strong> Why sbt? </p>

<p>The two main reasons to learn sbt is 
(a) that it is interactive and can be used inside a REPL, and 
(b) that you can write Scala to define your build tasks. 
The first makes it easier to experiment with new settings and execute/inspect your 
tasks instantly; and the second gives you the power of a programming language to define 
and customize all your build, compile, test and deploy tasks. 
At the same time, sbt offers incremental compilation that can 
significantly improve the compile performance of large Scala projects. </p>

<p>Let's start with an example project to explain the basics (assuming you have sbt installed). 
First create an empty directory, and then create the following files/directories: </p>

<p>1) A build file</p>

<p><strong>build.sbt</strong></p>

<div class="highlight highlight-source-scala"><pre>name <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>sbt-turorial<span class="pl-pds">"</span></span>
organization <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.sbt-tutorial<span class="pl-pds">"</span></span>
version <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1.0<span class="pl-pds">"</span></span>
scalaVersion <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>2.11.8<span class="pl-pds">"</span></span></pre></div>

<p>2) A very basic Scala class with a runnable <code>main()</code></p>

<p><strong>src/main/scala/org/sbttutorial/main/Main.scala</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">package</span> <span class="pl-en">org.sbttutorial.main</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> {
  println(<span class="pl-s"><span class="pl-pds">"</span>This is main()<span class="pl-pds">"</span></span>)
}</pre></div>

<p>3) Optionally if you want to specify the exact version of sbt</p>

<p><strong>project/build.properties</strong></p>

<div class="highlight highlight-source-scala"><pre>sbt.version <span class="pl-k">=</span> <span class="pl-c1">0.13.11</span></pre></div>

<p>This is it. Just these 2-3 simple files make for a fully functional sbt project with a lot of
features to learn and experiment. </p>

<p>First, type <code>sbt</code> from the root of your project (the folder containing <code>build.sbt</code>). 
This will get you to the interactive REPL of sbt. </p>

<p>Compile the project</p>

<pre><code>&gt; compile
</code></pre>

<p>Run the project </p>

<pre><code>&gt; run
</code></pre>

<p>Clean the compiled artifacts (e.g., .class) files generated by the compile task</p>

<pre><code>&gt; clean
</code></pre>

<p>You now have a way to compile your project, execute any main() class you have, and clean your project. </p>

<h4>
<a id="tasks-and-settings" class="anchor" href="#tasks-and-settings" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Tasks and Settings</h4>

<p>These are two of the most fundamental concepts in sbt. Understanding them is very important.<br>
You can think of sbt as a large collection of key-value pairs. Keys can be either tasks or settings. </p>

<p><strong>Task:</strong> A task is similar to a function in Scala. Like functions, 
tasks have return values and  every time you call a task some piece of code 
will be executed. Their main difference with functions is that tasks don't take arguments. 
(Sbt has a different kind of task called <a href="http://www.scala-sbt.org/0.13/docs/Input-Tasks.html">InputTask</a> 
that takes arguments, but we will focus on regular tasks in this tutorial.) 
Tasks can depend on other tasks or settings (so task and setting form a DAG of inter-dependencies).
From what we have used so far <code>compile, run, clean</code> are example of tasks.  </p>

<p><strong>Settings</strong>: Settings are like tasks in that they don't take arguments and they have a return value. 
However, unlike tasks that are similar to functions, settings are similar to <code>lazy vals</code> in Scala. 
The code in a setting will be executed just once and the return value will be returned the same every 
time the setting is referenced. The <code>name</code> of a project is an example of a setting. 
<strong>Unlike tasks that may depend on other tasks and settings, settings can only depend on other settings.</strong></p>

<p>Without getting into too many details, we are going to cover some examples of creating custom settings and tasks:</p>

<p><strong>Example of a Setting</strong></p>

<p>Add the following in you <code>build.sbt</code> file:</p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">confFileName</span> <span class="pl-k">=</span> settingKey[java.io.<span class="pl-en">File</span>](<span class="pl-s"><span class="pl-pds">"</span>Path to configuration settings<span class="pl-pds">"</span></span>)

confFileName <span class="pl-k">:</span><span class="pl-k">=</span> baseDirectory.value <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>conf<span class="pl-pds">"</span></span> <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>gen_file.txt<span class="pl-pds">"</span></span></pre></div>

<p>In this example, the <code>confFileName</code> setting depends on the <code>baseDirectory</code> setting. 
To execute a task or get the value of a setting we use the <code>.value</code> method. 
Every setting has 
(i) a name (so you can reference it) 
(ii) a short description, and 
(iii) a return type (in the example the type is <code>java.io.File</code>).</p>

<p>To get the value of the setting from the REPL simply type:</p>

<pre><code>&gt; confFileName
</code></pre>

<p><strong>Example of a Task</strong></p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">genConfFile</span> <span class="pl-k">=</span> taskKey[<span class="pl-k">Unit</span>](<span class="pl-s"><span class="pl-pds">"</span>Creates a dummy configuration file<span class="pl-pds">"</span></span>)

genConfFile <span class="pl-k">:</span><span class="pl-k">=</span> {
  <span class="pl-k">val</span> <span class="pl-en">time</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">java.util.Date</span>().toString
  println(time)
  <span class="pl-en">IO</span>.write(confFileName.value, s<span class="pl-s"><span class="pl-pds">"</span>time=$time<span class="pl-pds">"</span></span>)
}</pre></div>

<p>This example demonstrates one of the main benefits of sbt: you can use Scala to define your settings and tasks! 
<code>IO.write</code> is a convenient function offered by sbt to wrap Java's BufferedWriter. There is nothing preventing you
from using any Java or Scala IO libraries to achieve this. 
Again, to execute a task or get the value of a setting we use the <code>.value</code> method.
Finally, note that our example task depends on the <code>genConfFile</code> setting we defined earlier. </p>

<p>To execute the task from from the REPL simply type:</p>

<pre><code>&gt; genConfFile
</code></pre>

<p><strong>Example of modifying an existing Setting (or Task)</strong></p>

<p>Existing tasks and/or settings can be indirectly modified by changing the values
of other tasks/settings they depend on. We demonstrate this with an example. 
Our <code>genConfFile</code> task creates a new file every time it is called. 
It would be nice if sbt deleted that configuration file 
when we call <code>clean</code>. Here is how we can enhance the <code>clean</code> task to also 
clean the custom file we created:</p>

<div class="highlight highlight-source-scala"><pre>cleanFiles <span class="pl-k">:</span><span class="pl-k">=</span> confFileName.value <span class="pl-k">+</span><span class="pl-k">:</span> cleanFiles.value</pre></div>

<p>The <code>clean</code> task depends on the <code>cleanFiles</code> to get the list of files that need to be deleted. 
By changing adding one more file ine <code>cleanFiles</code> setting we idirectly alter the behavior of <code>clean</code>.
Now when we call <code>clean</code> sbt will also delete the configuration files we generated. </p>

<p>sbt has a lot of default settings and tasks. It is a good investment of your time to learn as many of them possible. 
Many of these settings and tasks are defined in <a href="https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala">sbt.Keys</a>. </p>

<p>Here is the content of out build.sbt file after the above additions:</p>

<div class="highlight highlight-source-scala"><pre>name <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>sbt-tutorial<span class="pl-pds">"</span></span>

version <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1.0<span class="pl-pds">"</span></span>

scalaVersion <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>2.11.8<span class="pl-pds">"</span></span>

organization <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.sbt-tutorial<span class="pl-pds">"</span></span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">confFileName</span> <span class="pl-k">=</span> settingKey[java.io.<span class="pl-en">File</span>](<span class="pl-s"><span class="pl-pds">"</span>Path to configuration settings<span class="pl-pds">"</span></span>)
confFileName <span class="pl-k">:</span><span class="pl-k">=</span> baseDirectory.value <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>conf<span class="pl-pds">"</span></span> <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>gen_file.txt<span class="pl-pds">"</span></span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">genConfFile</span> <span class="pl-k">=</span> taskKey[<span class="pl-k">Unit</span>](<span class="pl-s"><span class="pl-pds">"</span>Creates a dummy configuration file<span class="pl-pds">"</span></span>)
genConfFile <span class="pl-k">:</span><span class="pl-k">=</span> {
  <span class="pl-k">val</span> <span class="pl-en">time</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">java.util.Date</span>().toString
  println(time)
  <span class="pl-en">IO</span>.write(confFileName.value, s<span class="pl-s"><span class="pl-pds">"</span>time=$time<span class="pl-pds">"</span></span>)
}

cleanFiles <span class="pl-k">:</span><span class="pl-k">=</span> confFileName.value <span class="pl-k">+</span><span class="pl-k">:</span> cleanFiles.value</pre></div>

<h3>
<a id="interactive-mode" class="anchor" href="#interactive-mode" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Interactive mode</h3>

<p>We now move to the main topic of this tutorial. 
The interactive feature of sbt is one the main things that makes it great. We are going
to spend some time to demonstrate how to effectively utilize this feature. </p>

<p>Type <code>sbt</code> to get started</p>

<p><strong>show</strong></p>

<p>The show command will execute and print the return value of a task or setting in sbt. </p>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">&gt;</span> show name
[info] sbt<span class="pl-k">-</span>tutorial
<span class="pl-k">&gt;</span> show version
[info] <span class="pl-c1">1.0</span>
<span class="pl-k">&gt;</span> show organization
[info] org.sbt<span class="pl-k">-</span>tutorial
<span class="pl-k">&gt;</span> show scalaVersion
[info] <span class="pl-c1">2.11.8</span>
<span class="pl-k">&gt;</span> show baseDirectory
[info] <span class="pl-k">/</span><span class="pl-en">Users</span><span class="pl-k">/</span>xyz<span class="pl-k">/</span>sbt<span class="pl-k">-</span>turorial
<span class="pl-k">&gt;</span> show sources
[info] <span class="pl-en">ArrayBuffer</span>(<span class="pl-k">/</span><span class="pl-en">Users</span><span class="pl-k">/</span>xyz<span class="pl-k">/</span>sbt<span class="pl-k">-</span>turorial<span class="pl-k">/</span>src<span class="pl-k">/</span>main<span class="pl-k">/</span>scala<span class="pl-k">/</span>org<span class="pl-k">/</span>sbttutorial<span class="pl-k">/</span>main<span class="pl-k">/</span><span class="pl-en">Main</span>.scala)
[success] <span class="pl-en">Total</span> <span class="pl-v">time</span>: <span class="pl-c1">0</span> s, completed <span class="pl-en">Aug</span> <span class="pl-c1">14</span>, <span class="pl-c1">2016</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">37</span><span class="pl-k">:</span><span class="pl-c1">05</span> <span class="pl-en">PM</span>
<span class="pl-k">&gt;</span> show confFileName
[info] <span class="pl-k">/</span><span class="pl-en">Users</span><span class="pl-k">/</span>xyz<span class="pl-k">/</span>sbt<span class="pl-k">-</span>turorial<span class="pl-k">/</span>conf<span class="pl-k">/</span>gen_file.txt</pre></div>

<div class="highlight highlight-source-scala"><pre><span class="pl-k">&gt;</span> clean
[success] <span class="pl-en">Total</span> <span class="pl-v">time</span>: <span class="pl-c1">0</span> s, completed <span class="pl-en">Aug</span> <span class="pl-c1">14</span>, <span class="pl-c1">2016</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">22</span><span class="pl-k">:</span><span class="pl-c1">54</span> <span class="pl-en">PM</span>
<span class="pl-k">&gt;</span> show compile
[info] <span class="pl-en">Updating</span> {file<span class="pl-k">:</span><span class="pl-k">/</span><span class="pl-en">Users</span><span class="pl-k">/</span>xyz<span class="pl-k">/</span>sbt<span class="pl-k">-</span>turorial<span class="pl-k">/</span>}sbt<span class="pl-k">-</span>turorial...
[info] <span class="pl-en">Resolving</span> jline#jline;<span class="pl-c1">2.12.1</span> ...
[info] <span class="pl-en">Done</span> updating.
[info] <span class="pl-en">Compiling</span> <span class="pl-c1">1</span> <span class="pl-en">Scala</span> source to <span class="pl-k">/</span><span class="pl-en">Users</span><span class="pl-k">/</span>xyz<span class="pl-k">/</span>sbt<span class="pl-k">-</span>turorial<span class="pl-k">/</span>target<span class="pl-k">/</span>scala<span class="pl-k">-</span><span class="pl-c1">2.11</span><span class="pl-k">/</span>classes...
[info] <span class="pl-en">Analysis</span><span class="pl-k">:</span> <span class="pl-c1">1</span> <span class="pl-en">Scala</span> source, <span class="pl-c1">3</span> classes, <span class="pl-c1">2</span> binary dependencies
[success] <span class="pl-en">Total</span> <span class="pl-v">time</span>: <span class="pl-c1">1</span> s, completed <span class="pl-en">Aug</span> <span class="pl-c1">14</span>, <span class="pl-c1">2016</span> <span class="pl-c1">2</span><span class="pl-k">:</span><span class="pl-c1">22</span><span class="pl-k">:</span><span class="pl-c1">57</span> <span class="pl-en">PM</span></pre></div>

<p><strong>inspect</strong></p>

<p>Gives you a detailed description of a task or setting. 
Inspect is great for looking up commands and understanding the internals of sbt.</p>

<p>Here we use inspect to learn about the <em>name</em> setting we set in our <code>build.sbt</code> file.</p>

<pre><code> &gt; inspect name
 1.  [info] Setting: java.lang.String = sbt-tutorial
 2.  [info] Description:
 3.  [info]     Project name.
 4.  [info] Provided by:
 5.  [info]     {file:/Users/xyz/sbt-turorial/}sbt-turorial/*:name
 6.  [info] Defined at:
 7.  [info]     /Users/xyz/sbt-turorial/build.sbt:1
 8.  [info] Reverse dependencies:
 9.  [info]     *:projectInfo
 10. [info]     *:onLoadMessage
 11. [info]     *:description
 12. [info]     *:normalizedName
 13. [info] Delegates:
 14. [info]     *:name
 15. [info]     {.}/*:name
 16. [info]     */*:name
</code></pre>

<p>Line 1 says that this a <strong>setting</strong> with a return type being String and the return value being "sbt-tutorial".
Lines 2-3 give the description of the setting. Similarly, lines 4-5 we will talk more later. We can see in 
Line 7 that this setting is defined in the first line of out build.sbt file. 
Lines 8-12 show which other settings/tasks depend on this setting (that is, they use this setting internally). 
Lines 13-16 we will cover later in more detail. </p>

<pre><code>&gt; inspect sources
1.  [info] Task: scala.collection.Seq[java.io.File]
2.  [info] Description:
3.  [info]  All sources, both managed and unmanaged.
4.  [info] Provided by:
6.  [info]  {file:/Users/xyz/sbt-turorial/}sbt-turorial/compile:sources
6.  [info] Defined at:
7.  [info]  (sbt.Defaults) Defaults.scala:191
8.  [info] Dependencies:
9.  [info]  compile:unmanagedSources
10. [info]  compile:managedSources
11. [info] Delegates:
12. [info]  compile:sources
13. [info]  *:sources
14. [info]  {.}/compile:sources
15. [info]  {.}/*:sources
16. [info]  */compile:sources
17. [info]  */*:sources
18. [info] Related:
19. [info]  test:sources
</code></pre>

<p>Line 1 says that this is a <strong>task</strong> that returns a <code>Seq[java.io.File]</code>. 
Line 3 shows the description of the task. We now see in line 8-10 that this task depends on two other tasks/settings. 
So when we execute <code>sources</code> it will first run <code>unmanagedSources</code> and  <code>managedSources</code>. 
Finally, lines 18-19 give a list of similar tasks/settings (have same name) that are defined in other scopes (namespaces). 
We will discuss more about namespaces later.</p>

<p>Finally, here is the inspect on the custom task (genConfFile) we created before:</p>

<pre><code>&gt; inspect genConfFile
[info] Task: Unit
[info] Description:
[info]  Creates a dummy configuration file
[info] Provided by:
[info]  {file:/Users/xyz/sbt-turorial/}sbt-turorial/*:genConfFile
[info] Defined at:
[info]  /Users/xyz/sbt-turorial/build.sbt:16
[info] Dependencies:
[info]  *:confFileName
[info] Delegates:
[info]  *:genConfFile
[info]  {.}/*:genConfFile
[info]  */*:genConfFile
</code></pre>

<p><code>Unit</code> here means that our task does not have a return value. </p>

<p><strong>set</strong></p>

<p>This is a great tool when you experiment with different settings in a project. This command allows you to
change the value of a setting or a task without having to modify any code. The changes are ephemeral 
and remain active only during the current sbt REPL session. </p>

<pre><code>&gt; set name := "new-name"
[info] Defining *:name
[info] The new value will be used by *:description, *:normalizedName and 5 others.
[info]  Run `last` for details.
[info] Reapplying settings...
[info] Set current project to new-name (in build file:/Users/xyz/sbt-turorial/)
&gt; show name
[info] new-name
</code></pre>

<p>By default, sbt will run tasks in parallel (in the example below ignore the <code>::</code> notation for now). It essentially says
"give me the value of key <code>parallelExecution</code> used by task <code>test</code>."  </p>

<pre><code>&gt; show test::parallelExecution
[info] true

&gt; set parallelExecution in test := false
[info] Defining *:test::parallelExecution
[info] The new value will be used by test:test::testExecution
[info] Reapplying settings...
[info] Set current project to new-name (in build file:/Users/xyz/sbt-turorial/)
&gt; show test::parallelExecution
[info] false
</code></pre>

<p>This is really powerful. We can go and change the individual keys used by different tasks and then execute them
in the REPL to see the effect of our changes. To better understand task and setting in sbt we are going to take 
a look on how namespaces and scoping works. </p>

<h3>
<a id="namespaces" class="anchor" href="#namespaces" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Namespaces</h3>

<p>An important concept in sbt is how keys (settings, tasks, etc.) are organized into namespaces. 
sbt has three scope axis (think of it as a 3D coordinate system) for all its variables (keys): 
Project, Configuration, and Task. Project scope will make sense when we talk about multi-project builds, 
but for now, let's focus on the latter two, Configuration and Task. </p>

<p>You might have already noticed that some tasks, such as <code>compile</code>, can refer to different things depending 
on their context. For example, you might want to compile your test code, or compile everything but your test code. 
How does sbt knows what to do when you just say <code>compile</code>? The answer is that sbt does that by namespacing the 
compile task (and every other key) into different configurations. </p>

<p>By default there are three main configurations: Compile, Test, and Runtime. Compile groups together everything that 
has to do with managing your production code (the code located under <code>src/main</code>). For example, if you type <code>compile:compile</code> 
sbt will execute the compile task in the Compile configuration and compile just your production code (not your tests). 
Similarly, the Test configuration is responsible for all your test code (the code located under <code>src/test</code>). 
If you type <code>test:compile</code> it will run the compile task under the Test configuration. For the compile task,  <code>runtime:compile</code> is delicated to <code>compile:compile</code>, so nothing different happens in this case. You can see this
by yourself by inspecting the <code>runtime:compile</code> task and look under <em>Provided by</em>.</p>

<pre><code>&gt; inspect runtime:compile
[info] Task: sbt.inc.Analysis
[info] Description:
[info]  Compiles sources.
[info] Provided by:
[info]  {file:/Users/xyz/sbt-tutorial/root-only/}root-only/compile:compile
[info] Defined at:
[info]  (sbt.Defaults) Defaults.scala:271
...
</code></pre>

<p>Here are some examples of Coniguration/Task keys:</p>

<pre><code>&gt; show runtime:sources
[info] ArrayBuffer(/Users/xyz/sbt-tutorial/root-only/src/main/scala/org/sbttutorial/main/Main.scala)
[success] Total time: 0 s, completed Aug 16, 2016 9:36:55 PM
&gt; show compile:sources
[info] ArrayBuffer(/Users/xyz/sbt-tutorial/root-only/src/main/scala/org/sbttutorial/main/Main.scala)
[success] Total time: 0 s, completed Aug 16, 2016 9:37:02 PM
&gt; show test:sources
[info] ArrayBuffer()
</code></pre>

<p>Runtime and Compile have the same sources, whereas for Test we don't have any test classes, so the <code>sources</code> returns empty. </p>

<p>In the example below we tell sbt to create a new JVM when we execute <code>run</code>, but
use the same JVM as sbt when we execute tests.  </p>

<pre><code>&gt; set fork in Compile := true
[info] Defining compile:fork
[info] The new value will be used by compile:run::runner
&gt; set fork in Test := false
[info] Defining test:fork
[info] The new value will be used by test:run::runner, test:testGrouping
</code></pre>

<p>The last example shows that <code>test:fork</code> is used by <code>test:run::runner</code> 
and <code>test:testGrouping</code>. What if we wanted to fork a new JVM each time we execute <code>test:run</code> 
but not every time we run our tests? sbt allows us to focus into the Configuration 
and the Task:</p>

<pre><code> set fork in testGrouping in (Test, run) := false
 &gt; show test:testGrouping::fork
[info] false
...
set fork in runner in (Test, run) := true
&gt; show test:runner::fork
[info] true
...
&gt; show test:run::fork
[info] true
&gt; show test:fork
[info] false
</code></pre>

<p>We have exactly what we wanted. We create a new JVM when we execute <code>test:run</code> 
(this will execute a Main function defined inside our test classes) but we
don't fork a JVM when we simple run our tests <code>test:test</code>.
You can see how powerful this is. We can manipulate different tasks by changing 
the values of the tasks or settings that it depends upon. The interactive shell will
be the users best friend while trying to figure these out.  </p>

<h4>
<a id="understandin-the-sbt-scope-syntax" class="anchor" href="#understandin-the-sbt-scope-syntax" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Understandin the sbt scope syntax</h4>

<p>Here, is better to think of the scoe axis as a 3-tired namespace: <strong>1) Project, 2) Configuration, and 3) Task</strong></p>

<p>Here is how you navigate to these dimensions from sbt interactive: </p>

<pre><code>&lt;project-id&gt;/config:intask::key
</code></pre>

<p>This essentially says: execute from project X (first dimension) and configuration Compile (second dimension) 
the run task (third dimension). This will execute the main function found in the compile 
(under main/src folder) code of project X. </p>

<pre><code>&gt; projectX/compile:run
</code></pre>

<p>Similarly you can say execute run in the Test configuration of project X. This will now execute the main method (say you have one defined) that is under the test/src folder. </p>

<pre><code>&gt; projectX/test:run
</code></pre>

<p>Now, tasks also have keys (internal configuration variables). For example: </p>

<pre><code>&gt; show projectX/compile:compile::sources
</code></pre>

<p>This will show the source files used by the compile task of Project-X's Compile configuration (when you compile just your code, not the tests). </p>

<pre><code>&gt; show projectX/test:compile::sources
</code></pre>

<p>This will show the source files used by the compile task of Project-X's Test configuration (when you compile just your test files).</p>

<h4>
<a id="naming-in-sbt-dsl" class="anchor" href="#naming-in-sbt-dsl" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Naming in SBT DSL</h4>

<p>sbt has different convention for naming tasks and scopes while you are writing in its DSL (inside .sbt files) and while executing tasks interactively via the sbt cli. </p>

<pre><code>projectX/test:compile::sources
</code></pre>

<p>translates to </p>

<pre><code>sources in (Test,compile) in projectX
</code></pre>

<p>sbt has a lot of default scopes. For example, if you just enter sbt and type <code>compile</code>, it will actually execute the compile task under the Compile configuration of the Root project.  </p>
        </section>

        <footer>
          Sbt-interactive-tutorial is maintained by <a href="https://github.com/imarios">imarios</a><br>
          This page was generated by <a href="https://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>
