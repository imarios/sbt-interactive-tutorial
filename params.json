{
  "name": "Sbt-interactive-tutorial",
  "tagline": "A tutorial that emphasizes how to use sbt as an interactive build tool. ",
  "body": "## sbt: The interactive tutorial\r\n*(Covers Scala 2.11.8 and sbt 0.13.11)*\r\n\r\n\r\n**Goal:** The goal of this tutorial is to emphasize on how to use sbt as an interactive build tool. \r\nIt targets audience that is new to sbt or has been using sbt for few months.\r\n\r\n\r\n**Q:** Why sbt? \r\n\r\nThe two main reasons to learn sbt is \r\n(a) that it is interactive and can be used inside a REPL, and \r\n(b) that you can write Scala to define your build tasks. \r\nThe first makes it easier to experiment with new settings and execute/inspect your \r\ntasks instantly; and the second gives you the power of a programming language to define \r\nand customize all your build, compile, test and deploy tasks. \r\nAt the same time, sbt offers incremental compilation that can \r\nsignificantly improve the compile performance of large Scala projects. \r\n\r\nLet's start with an example project to explain the basics (assuming you have sbt installed). \r\nFirst create an empty directory, and then create the following files/directories: \r\n\r\n1) A build file\r\n \r\n**build.sbt**\r\n\r\n```sbt\r\nname := \"sbt-turorial\"\r\norganization := \"org.sbt-tutorial\"\r\nversion := \"1.0\"\r\nscalaVersion := \"2.11.8\"\r\n```\r\n\r\n2) A very basic Scala class with a runnable `main()`\r\n\r\n**src/main/scala/org/sbttutorial/main/Main.scala**\r\n\r\n```Scala\r\npackage org.sbttutorial.main\r\n\r\nobject Main extends App {\r\n  println(\"This is main()\")\r\n}\r\n```\r\n\r\n3) Optionally if you want to specify the exact version of sbt\r\n\r\n**project/build.properties**\r\n\r\n```sbt\r\nsbt.version = 0.13.11\r\n```\r\n\r\n\r\nThis is it. Just these 2-3 simple files make for a fully functional sbt project with a lot of\r\nfeatures to learn and experiment. \r\n\r\nFirst, type `sbt` from the root of your project (the folder containing `build.sbt`). \r\nThis will get you to the interactive REPL of sbt. \r\n\r\nCompile the project\r\n\r\n```\r\n> compile\r\n```\r\n\r\nRun the project \r\n\r\n```\r\n> run\r\n```\r\n\r\nClean the compiled artifacts (e.g., .class) files generated by the compile task\r\n\r\n```\r\n> clean\r\n```\r\n\r\nYou now have a way to compile your project, execute any main() class you have, and clean your project. \r\n\r\n\r\n#### Tasks and Settings \r\n\r\nThese are two of the most fundamental concepts in sbt. Understanding them is very important.  \r\nYou can think of sbt as a large collection of key-value pairs. Keys can be either tasks or settings. \r\n\r\n**Task:** A task is similar to a function in Scala. Like functions, \r\ntasks have return values and  every time you call a task some piece of code \r\nwill be executed. Their main difference with functions is that tasks don't take arguments. \r\n(Sbt has a different kind of task called [InputTask](http://www.scala-sbt.org/0.13/docs/Input-Tasks.html) \r\nthat takes arguments, but we will focus on regular tasks in this tutorial.) \r\nTasks can depend on other tasks or settings (so task and setting form a DAG of inter-dependencies).\r\nFrom what we have used so far `compile, run, clean` are example of tasks.  \r\n\r\n\r\n**Settings**: Settings are like tasks in that they don't take arguments and they have a return value. \r\nHowever, unlike tasks that are similar to functions, settings are similar to `lazy vals` in Scala. \r\nThe code in a setting will be executed just once and the return value will be returned the same every \r\ntime the setting is referenced. The `name` of a project is an example of a setting. \r\n**Unlike tasks that may depend on other tasks and settings, settings can only depend on other settings.**\r\n\r\n\r\nWithout getting into too many details, we are going to cover some examples of creating custom settings and tasks:\r\n\r\n**Example of a Setting**\r\n\r\nAdd the following in you `build.sbt` file:\r\n\r\n```SBT\r\nlazy val confFileName = settingKey[java.io.File](\"Path to configuration settings\")\r\n\r\nconfFileName := baseDirectory.value / \"conf\" / \"gen_file.txt\"\r\n```\r\n\r\nIn this example, the `confFileName` setting depends on the `baseDirectory` setting. \r\nTo execute a task or get the value of a setting we use the `.value` method. \r\nEvery setting has \r\n(i) a name (so you can reference it) \r\n(ii) a short description, and \r\n(iii) a return type (in the example the type is `java.io.File`).\r\n\r\nTo get the value of the setting from the REPL simply type:\r\n\r\n```\r\n> confFileName\r\n```\r\n\r\n**Example of a Task**\r\n\r\n```SBT\r\nlazy val genConfFile = taskKey[Unit](\"Creates a dummy configuration file\")\r\n\r\ngenConfFile := {\r\n  val time: String = new java.util.Date().toString\r\n  println(time)\r\n  IO.write(confFileName.value, s\"time=$time\")\r\n}\r\n```\r\n\r\nThis example demonstrates one of the main benefits of sbt: you can use Scala to define your settings and tasks! \r\n`IO.write` is a convenient function offered by sbt to wrap Java's BufferedWriter. There is nothing preventing you\r\nfrom using any Java or Scala IO libraries to achieve this. \r\nAgain, to execute a task or get the value of a setting we use the `.value` method.\r\nFinally, note that our example task depends on the `genConfFile` setting we defined earlier. \r\n\r\n\r\nTo execute the task from from the REPL simply type:\r\n\r\n```\r\n> genConfFile\r\n```\r\n\r\n**Example of modifying an existing Setting (or Task)**\r\n\r\nExisting tasks and/or settings can be indirectly modified by changing the values\r\nof other tasks/settings they depend on. We demonstrate this with an example. \r\nOur `genConfFile` task creates a new file every time it is called. \r\nIt would be nice if sbt deleted that configuration file \r\nwhen we call `clean`. Here is how we can enhance the `clean` task to also \r\nclean the custom file we created:\r\n\r\n```SBT\r\ncleanFiles := confFileName.value +: cleanFiles.value\r\n```\r\n\r\nThe `clean` task depends on the `cleanFiles` to get the list of files that need to be deleted. \r\nBy changing adding one more file ine `cleanFiles` setting we idirectly alter the behavior of `clean`.\r\nNow when we call `clean` sbt will also delete the configuration files we generated. \r\n\r\nsbt has a lot of default settings and tasks. It is a good investment of your time to learn as many of them possible. \r\nMany of these settings and tasks are defined in [sbt.Keys](https://github.com/sbt/sbt/blob/0.13/main/src/main/scala/sbt/Keys.scala). \r\n\r\n\r\nHere is the content of out build.sbt file after the above additions:\r\n\r\n```sbt\r\nname := \"sbt-tutorial\"\r\n\r\nversion := \"1.0\"\r\n\r\nscalaVersion := \"2.11.8\"\r\n\r\norganization := \"org.sbt-tutorial\"\r\n\r\nlazy val confFileName = settingKey[java.io.File](\"Path to configuration settings\")\r\nconfFileName := baseDirectory.value / \"conf\" / \"gen_file.txt\"\r\n\r\nlazy val genConfFile = taskKey[Unit](\"Creates a dummy configuration file\")\r\ngenConfFile := {\r\n  val time: String = new java.util.Date().toString\r\n  println(time)\r\n  IO.write(confFileName.value, s\"time=$time\")\r\n}\r\n\r\ncleanFiles := confFileName.value +: cleanFiles.value\r\n```\r\n\r\n\r\n### Interactive mode\r\n\r\nWe now move to the main topic of this tutorial. \r\nThe interactive feature of sbt is one the main things that makes it great. We are going\r\nto spend some time to demonstrate how to effectively utilize this feature. \r\n\r\nType `sbt` to get started\r\n\r\n\r\n**show**\r\n\r\nThe show command will execute and print the return value of a task or setting in sbt. \r\n\r\n``` sbt\r\n> show name\r\n[info] sbt-tutorial\r\n> show version\r\n[info] 1.0\r\n> show organization\r\n[info] org.sbt-tutorial\r\n> show scalaVersion\r\n[info] 2.11.8\r\n> show baseDirectory\r\n[info] /Users/xyz/sbt-turorial\r\n> show sources\r\n[info] ArrayBuffer(/Users/xyz/sbt-turorial/src/main/scala/org/sbttutorial/main/Main.scala)\r\n[success] Total time: 0 s, completed Aug 14, 2016 2:37:05 PM\r\n> show confFileName\r\n[info] /Users/xyz/sbt-turorial/conf/gen_file.txt\r\n``` \r\n\r\n``` sbt\r\n> clean\r\n[success] Total time: 0 s, completed Aug 14, 2016 2:22:54 PM\r\n> show compile\r\n[info] Updating {file:/Users/xyz/sbt-turorial/}sbt-turorial...\r\n[info] Resolving jline#jline;2.12.1 ...\r\n[info] Done updating.\r\n[info] Compiling 1 Scala source to /Users/xyz/sbt-turorial/target/scala-2.11/classes...\r\n[info] Analysis: 1 Scala source, 3 classes, 2 binary dependencies\r\n[success] Total time: 1 s, completed Aug 14, 2016 2:22:57 PM\r\n```\r\n\r\n**inspect**\r\n\r\nGives you a detailed description of a task or setting. \r\nInspect is great for looking up commands and understanding the internals of sbt.\r\n\r\n\r\nHere we use inspect to learn about the *name* setting we set in our `build.sbt` file.\r\n \r\n ```\r\n > inspect name\r\n 1.  [info] Setting: java.lang.String = sbt-tutorial\r\n 2.  [info] Description:\r\n 3.  [info] \tProject name.\r\n 4.  [info] Provided by:\r\n 5.  [info] \t{file:/Users/xyz/sbt-turorial/}sbt-turorial/*:name\r\n 6.  [info] Defined at:\r\n 7.  [info] \t/Users/xyz/sbt-turorial/build.sbt:1\r\n 8.  [info] Reverse dependencies:\r\n 9.  [info] \t*:projectInfo\r\n 10. [info] \t*:onLoadMessage\r\n 11. [info] \t*:description\r\n 12. [info] \t*:normalizedName\r\n 13. [info] Delegates:\r\n 14. [info] \t*:name\r\n 15. [info] \t{.}/*:name\r\n 16. [info] \t*/*:name\r\n ```\r\n\r\nLine 1 says that this a **setting** with a return type being String and the return value being \"sbt-tutorial\".\r\nLines 2-3 give the description of the setting. Similarly, lines 4-5 we will talk more later. We can see in \r\nLine 7 that this setting is defined in the first line of out build.sbt file. \r\nLines 8-12 show which other settings/tasks depend on this setting (that is, they use this setting internally). \r\nLines 13-16 we will cover later in more detail. \r\n\r\n```\r\n> inspect sources\r\n1.  [info] Task: scala.collection.Seq[java.io.File]\r\n2.  [info] Description:\r\n3.  [info] \tAll sources, both managed and unmanaged.\r\n4.  [info] Provided by:\r\n6.  [info] \t{file:/Users/xyz/sbt-turorial/}sbt-turorial/compile:sources\r\n6.  [info] Defined at:\r\n7.  [info] \t(sbt.Defaults) Defaults.scala:191\r\n8.  [info] Dependencies:\r\n9.  [info] \tcompile:unmanagedSources\r\n10. [info] \tcompile:managedSources\r\n11. [info] Delegates:\r\n12. [info] \tcompile:sources\r\n13. [info] \t*:sources\r\n14. [info] \t{.}/compile:sources\r\n15. [info] \t{.}/*:sources\r\n16. [info] \t*/compile:sources\r\n17. [info] \t*/*:sources\r\n18. [info] Related:\r\n19. [info] \ttest:sources\r\n```\r\nLine 1 says that this is a **task** that returns a `Seq[java.io.File]`. \r\nLine 3 shows the description of the task. We now see in line 8-10 that this task depends on two other tasks/settings. \r\nSo when we execute `sources` it will first run `unmanagedSources` and  `managedSources`. \r\nFinally, lines 18-19 give a list of similar tasks/settings (have same name) that are defined in other scopes (namespaces). \r\nWe will discuss more about namespaces later.\r\n\r\nFinally, here is the inspect on the custom task (genConfFile) we created before:\r\n\r\n```\r\n> inspect genConfFile\r\n[info] Task: Unit\r\n[info] Description:\r\n[info] \tCreates a dummy configuration file\r\n[info] Provided by:\r\n[info] \t{file:/Users/xyz/sbt-turorial/}sbt-turorial/*:genConfFile\r\n[info] Defined at:\r\n[info] \t/Users/xyz/sbt-turorial/build.sbt:16\r\n[info] Dependencies:\r\n[info] \t*:confFileName\r\n[info] Delegates:\r\n[info] \t*:genConfFile\r\n[info] \t{.}/*:genConfFile\r\n[info] \t*/*:genConfFile\r\n```\r\n\r\n`Unit` here means that our task does not have a return value. \r\n\r\n\r\n**set**\r\n\r\nThis is a great tool when you experiment with different settings in a project. This command allows you to\r\nchange the value of a setting or a task without having to modify any code. The changes are ephemeral \r\nand remain active only during the current sbt REPL session. \r\n\r\n```\r\n> set name := \"new-name\"\r\n[info] Defining *:name\r\n[info] The new value will be used by *:description, *:normalizedName and 5 others.\r\n[info] \tRun `last` for details.\r\n[info] Reapplying settings...\r\n[info] Set current project to new-name (in build file:/Users/xyz/sbt-turorial/)\r\n> show name\r\n[info] new-name\r\n```\r\n\r\nBy default, sbt will run tasks in parallel (in the example below ignore the `::` notation for now). It essentially says\r\n\"give me the value of key `parallelExecution` used by task `test`.\"  \r\n\r\n```\r\n> show test::parallelExecution\r\n[info] true\r\n\r\n> set parallelExecution in test := false\r\n[info] Defining *:test::parallelExecution\r\n[info] The new value will be used by test:test::testExecution\r\n[info] Reapplying settings...\r\n[info] Set current project to new-name (in build file:/Users/xyz/sbt-turorial/)\r\n> show test::parallelExecution\r\n[info] false\r\n```\r\n\r\nThis is really powerful. We can go and change the individual keys used by different tasks and then execute them\r\nin the REPL to see the effect of our changes. To better understand task and setting in sbt we are going to take \r\na look on how namespaces and scoping works. \r\n\r\n\r\n### Namespaces\r\n\r\nAn important concept in sbt is how keys (settings, tasks, etc.) are organized into namespaces. \r\nsbt has three scope axis (think of it as a 3D coordinate system) for all its variables (keys): \r\nProject, Configuration, and Task. Project scope will make sense when we talk about multi-project builds, \r\nbut for now, let's focus on the latter two, Configuration and Task. \r\n\r\nYou might have already noticed that some tasks, such as `compile`, can refer to different things depending \r\non their context. For example, you might want to compile your test code, or compile everything but your test code. \r\nHow does sbt knows what to do when you just say `compile`? The answer is that sbt does that by namespacing the \r\ncompile task (and every other key) into different configurations. \r\n\r\nBy default there are three main configurations: Compile, Test, and Runtime. Compile groups together everything that \r\nhas to do with managing your production code (the code located under `src/main`). For example, if you type `compile:compile` \r\nsbt will execute the compile task in the Compile configuration and compile just your production code (not your tests). \r\nSimilarly, the Test configuration is responsible for all your test code (the code located under `src/test`). \r\nIf you type `test:compile` it will run the compile task under the Test configuration. For the compile task,  `runtime:compile` is delicated to `compile:compile`, so nothing different happens in this case. You can see this\r\nby yourself by inspecting the `runtime:compile` task and look under *Provided by*.\r\n\r\n```\r\n> inspect runtime:compile\r\n[info] Task: sbt.inc.Analysis\r\n[info] Description:\r\n[info] \tCompiles sources.\r\n[info] Provided by:\r\n[info] \t{file:/Users/xyz/sbt-tutorial/root-only/}root-only/compile:compile\r\n[info] Defined at:\r\n[info] \t(sbt.Defaults) Defaults.scala:271\r\n...\r\n```\r\n\r\nHere are some examples of Coniguration/Task keys:\r\n\r\n```\r\n> show runtime:sources\r\n[info] ArrayBuffer(/Users/xyz/sbt-tutorial/root-only/src/main/scala/org/sbttutorial/main/Main.scala)\r\n[success] Total time: 0 s, completed Aug 16, 2016 9:36:55 PM\r\n> show compile:sources\r\n[info] ArrayBuffer(/Users/xyz/sbt-tutorial/root-only/src/main/scala/org/sbttutorial/main/Main.scala)\r\n[success] Total time: 0 s, completed Aug 16, 2016 9:37:02 PM\r\n> show test:sources\r\n[info] ArrayBuffer()\r\n```\r\n\r\nRuntime and Compile have the same sources, whereas for Test we don't have any test classes, so the `sources` returns empty. \r\n\r\n\r\nIn the example below we tell sbt to create a new JVM when we execute `run`, but\r\nuse the same JVM as sbt when we execute tests.  \r\n\r\n```\r\n> set fork in Compile := true\r\n[info] Defining compile:fork\r\n[info] The new value will be used by compile:run::runner\r\n> set fork in Test := false\r\n[info] Defining test:fork\r\n[info] The new value will be used by test:run::runner, test:testGrouping\r\n```\r\n\r\nThe last example shows that `test:fork` is used by `test:run::runner` \r\nand `test:testGrouping`. What if we wanted to fork a new JVM each time we execute `test:run` \r\nbut not every time we run our tests? sbt allows us to focus into the Configuration \r\nand the Task:\r\n\r\n```\r\n set fork in testGrouping in (Test, run) := false\r\n > show test:testGrouping::fork\r\n[info] false\r\n...\r\nset fork in runner in (Test, run) := true\r\n> show test:runner::fork\r\n[info] true\r\n...\r\n> show test:run::fork\r\n[info] true\r\n> show test:fork\r\n[info] false\r\n```\r\n\r\nWe have exactly what we wanted. We create a new JVM when we execute `test:run` \r\n(this will execute a Main function defined inside our test classes) but we\r\ndon't fork a JVM when we simple run our tests `test:test`.\r\nYou can see how powerful this is. We can manipulate different tasks by changing \r\nthe values of the tasks or settings that it depends upon. The interactive shell will\r\nbe the users best friend while trying to figure these out.  \r\n\r\n\r\n#### Understandin the sbt scope syntax\r\n\r\nHere, is better to think of the scoe axis as a 3-tired namespace: **1) Project, 2) Configuration, and 3) Task**\r\n\r\nHere is how you navigate to these dimensions from sbt interactive: \r\n\r\n```\r\n<project-id>/config:intask::key\r\n```\r\n\r\nThis essentially says: execute from project X (first dimension) and configuration Compile (second dimension) \r\nthe run task (third dimension). This will execute the main function found in the compile \r\n(under main/src folder) code of project X. \r\n\r\n\r\n    > projectX/compile:run\r\n\r\nSimilarly you can say execute run in the Test configuration of project X. This will now execute the main method (say you have one defined) that is under the test/src folder. \r\n\r\n    > projectX/test:run\r\n\r\n \r\nNow, tasks also have keys (internal configuration variables). For example: \r\n\r\n    > show projectX/compile:compile::sources\r\n\r\nThis will show the source files used by the compile task of Project-X's Compile configuration (when you compile just your code, not the tests). \r\n \r\n\r\n    > show projectX/test:compile::sources\r\n\r\n \r\nThis will show the source files used by the compile task of Project-X's Test configuration (when you compile just your test files).\r\n\r\n#### Naming in SBT DSL\r\n\r\nsbt has different convention for naming tasks and scopes while you are writing in its DSL (inside .sbt files) and while executing tasks interactively via the sbt cli. \r\n\r\n    projectX/test:compile::sources\r\n\r\ntranslates to \r\n\r\n    sources in (Test,compile) in projectX\r\n\r\n \r\n\r\nsbt has a lot of default scopes. For example, if you just enter sbt and type `compile`, it will actually execute the compile task under the Compile configuration of the Root project.  \r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}